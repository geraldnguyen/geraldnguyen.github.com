<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jsr303 Bean Validation on Gerald Nguyen</title>
    <link>https://geraldnguyen.github.io/tags/jsr303-bean-validation/</link>
    <description>Recent content in Jsr303 Bean Validation on Gerald Nguyen</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 Dec 2012 09:19:42 +0100</lastBuildDate>
    <atom:link href="https://geraldnguyen.github.io/tags/jsr303-bean-validation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JSR 303 – Bean Validation – Let Your Bean Validate Itself</title>
      <link>https://geraldnguyen.github.io/posts/2012/12/2012-12-20-jsr303-bean-validation-self-validating-bean/</link>
      <pubDate>Thu, 20 Dec 2012 09:19:42 +0100</pubDate>
      <guid>https://geraldnguyen.github.io/posts/2012/12/2012-12-20-jsr303-bean-validation-self-validating-bean/</guid>
      <description>&lt;p&gt;This is a simple application of my &lt;a href=&#34;https://geraldnguyen.github.io/posts/2012/08/2012-08-25-jsr303-bean-validation-custom-constraints/&#34;&gt;previous post&lt;/a&gt; whereby you can develop your own validation rule and enforcer.&lt;/p&gt;&#xA;&lt;p&gt;The significance of this application is the use of &lt;code&gt;SelfValidate&lt;/code&gt; interface to enable bean to define its own validation method and validator to invoke bean’s method. Typically this constraint is apply to a type, but application on field is also possible.&lt;/p&gt;&#xA;&lt;h2 id=&#34;constraint-annotation&#34;&gt;Constraint Annotation&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Target({ElementType.TYPE})&#xA;@Retention(RetentionPolicy.RUNTIME)&#xA;@Constraint(validatedBy=SelfValidator.class)&#xA; &#xA;public @interface SelfValidation {&#xA;   String message() default &amp;#34;Self-validation failed&amp;#34;;&#xA;   Class[] groups() default {};&#xA;   Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};&#xA;}&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>JSR 303 – Bean Validation – Custom Constraints</title>
      <link>https://geraldnguyen.github.io/posts/2012/08/2012-08-25-jsr303-bean-validation-custom-constraints/</link>
      <pubDate>Sat, 25 Aug 2012 09:19:42 +0100</pubDate>
      <guid>https://geraldnguyen.github.io/posts/2012/08/2012-08-25-jsr303-bean-validation-custom-constraints/</guid>
      <description>&lt;p&gt;So far, we have learn the &lt;a href=&#34;https://geraldnguyen.github.io/posts/2012/08/2012-08-03-jsr303-bean-validation-basic/&#34;&gt;basic&lt;/a&gt; and a not-so-common &lt;a href=&#34;https://geraldnguyen.github.io/posts/2012/08/2012-08-09-jsr303-bean-validation-nested-validation/&#34;&gt;nested usage&lt;/a&gt; of JSR 303 Bean Validation, it’s time to learn how the declarative validation rule was implemented. In another word, we will learn to create a custom constraint this this post.&lt;/p&gt;&#xA;&lt;h2 id=&#34;constraint-annotation&#34;&gt;Constraint Annotation&lt;/h2&gt;&#xA;&lt;p&gt;Custom constraint is a special kind of annotation that is itself annotated with &lt;code&gt;@javax.validation.Constraint&lt;/code&gt; annotation. For example:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Target({ElementType.FIELD})&#xA;@Retention(RetentionPolicy.RUNTIME)&#xA;@Constraint(validatedBy=CustomeValidator.class) &#xA;public @interface CustomConstraint {&#xA;   String message() default &amp;#34;Custom validation failed&amp;#34;;&#xA;   Class[] groups() default {};&#xA;   Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};&#xA;}&#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>JSR 303 – Bean Validation – Nested Validation</title>
      <link>https://geraldnguyen.github.io/posts/2012/08/2012-08-09-jsr303-bean-validation-nested-validation/</link>
      <pubDate>Thu, 09 Aug 2012 09:19:42 +0100</pubDate>
      <guid>https://geraldnguyen.github.io/posts/2012/08/2012-08-09-jsr303-bean-validation-nested-validation/</guid>
      <description>&lt;p&gt;Following up from my &lt;a href=&#34;https://geraldnguyen.github.io/posts/2012/08/2012-08-03-jsr303-bean-validation-basic/&#34;&gt;previous post&lt;/a&gt; about JSR 303 – Bean Validation, we will see how to apply it to any nested property and how to display validation error on screen using Spring MVC’s JSP tags&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-bean-validation-on-nested-property&#34;&gt;1. Bean Validation on Nested Property&lt;/h2&gt;&#xA;&lt;p&gt;Recall that to validate any property, we only need to put a &lt;em&gt;Constraint&lt;/em&gt; annotation on top of its declaration. Example of common constraints are &lt;code&gt;@NotEmpty&lt;/code&gt;, &lt;code&gt;@Pattern&lt;/code&gt;, &lt;code&gt;@Email&lt;/code&gt;. One thing in common of these constraints are that the applied property has to be of type &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>JSR 303 – Bean Validation – Basic</title>
      <link>https://geraldnguyen.github.io/posts/2012/08/2012-08-03-jsr303-bean-validation-basic/</link>
      <pubDate>Fri, 03 Aug 2012 09:19:42 +0100</pubDate>
      <guid>https://geraldnguyen.github.io/posts/2012/08/2012-08-03-jsr303-bean-validation-basic/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://jcp.org/en/jsr/detail?id=303&#34;&gt;JSR 303 – Bean Validation&lt;/a&gt; is defines a metadata model and API for JavaBean validation. The metadata is primarily in Annotation forms, with the possibility of being overridden or extended by XML descriptors. &lt;a href=&#34;http://www.hibernate.org/subprojects/validator.html&#34;&gt;Hibernate Validator&lt;/a&gt; is the reference implementation of JSR 303.&lt;/p&gt;&#xA;&lt;p&gt;The current version, as of August 2nd, 2012, of JSR303 is 1.0, and of  Hibernate Validator version is 4.0.1.&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-example&#34;&gt;1. Example&lt;/h2&gt;&#xA;&lt;p&gt;A straightforward use of Bean Validation is to document and specify validation rules on JavaBean’s properties. In the below example, it is easy to deduce that field &lt;em&gt;manufacturer&lt;/em&gt;, &lt;em&gt;licensePlate&lt;/em&gt; and &lt;em&gt;seatCount&lt;/em&gt; are mandatory while &lt;em&gt;note&lt;/em&gt; is not. In addition, &lt;em&gt;licencePlate&lt;/em&gt; must contain at least 2 and at most 14 characters; &lt;em&gt;seatCount&lt;/em&gt; must be equal or higher than 2.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
