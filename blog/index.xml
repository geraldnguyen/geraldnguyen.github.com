<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on</title><link>/blog/</link><description>Recent content in Blog on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Fri, 03 Sep 2021 09:19:42 +0100</lastBuildDate><atom:link href="/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Java Try-with-resource</title><link>/blog/java-try-with-resource/</link><pubDate>Fri, 03 Sep 2021 09:19:42 +0100</pubDate><guid>/blog/java-try-with-resource/</guid><description>Overview If my memory serves, I used to do such boring lengthly track-and-close A LOT!
public void executeQuery(String sql) throws SQLException { Connection conn; PreparedStatement stmt; try { conn = getConnection(); stmt = conn.prepareStatement(sql); stmt.executeQuery(); } finally { if (stmt != null) { stmt.close(); } if (conn != null) { conn.close(); } } } The above can be just as short as below
public void executeQuery(String sql) throws SQLException { try ( Connection conn = getConnection(); PreparedStatement stmt = conn.</description></item><item><title>javax.transaction.Transactional vs org.springframework.transaction.annotation.Transactional</title><link>/blog/javax.transaction.transactional-vs-org.springframework.transaction.annotation.transactional/</link><pubDate>Thu, 10 Sep 2020 09:19:42 +0100</pubDate><guid>/blog/javax.transaction.transactional-vs-org.springframework.transaction.annotation.transactional/</guid><description>If you’re using Spring or Spring Boot, then use the Spring @Transactional annotation, as it allows you to configure more attributes than the Java EE @Transactional annotation.
If you are using Java EE alone, and you deploy your application on a Java EE application server, then use the Java EE @Transactional annotation.
https://stackoverflow.com/a/62702146/575457</description></item><item><title>The best way to fix the Hibernate MultipleBagFetchException</title><link>/blog/the-best-way-to-fix-the-hibernate-multiplebagfetchexception/</link><pubDate>Thu, 10 Sep 2020 09:19:42 +0100</pubDate><guid>/blog/the-best-way-to-fix-the-hibernate-multiplebagfetchexception/</guid><description>First: How NOT to “fix”: Using Set instead of List See the original article
Recommended fix: Instead of executing a single JPQL query that fetches two associations, we can execute two JPQL queries instead List&amp;lt;Post&amp;gt; posts = doInJPA(entityManager -&amp;gt; { List&amp;lt;Post&amp;gt; _posts = entityManager .createQuery( &amp;quot;select distinct p &amp;quot; + &amp;quot;from Post p &amp;quot; + &amp;quot;left join fetch p.comments &amp;quot; + &amp;quot;where p.id between :minId and :maxId &amp;quot;, Post.class) .setParameter(&amp;quot;minId&amp;quot;, 1L) .</description></item><item><title>JSR 303 – Bean Validation – Let Your Bean Validate Itself</title><link>/blog/jsr-303-bean-validation-let-your-bean-validate-itself/</link><pubDate>Thu, 20 Dec 2012 09:19:42 +0100</pubDate><guid>/blog/jsr-303-bean-validation-let-your-bean-validate-itself/</guid><description>This is a simple application of my previous post whereby you can develop your own validation rule and enforcer.
The significance of this application is the use of SelfValidate interface to enable bean to define its own validation method and validator to invoke bean’s method. Typically this constraint is apply to a type, but application on field is also possible.
Constraint Annotation @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy=SelfValidator.class) public @interface SelfValidation { String message() default &amp;quot;Self-validation failed&amp;quot;; Class[] groups() default {}; Class&amp;lt;?</description></item><item><title>JSR 303 – Bean Validation – Custom Constraints</title><link>/blog/jsr-303-bean-validation-custom-constraints/</link><pubDate>Sat, 25 Aug 2012 09:19:42 +0100</pubDate><guid>/blog/jsr-303-bean-validation-custom-constraints/</guid><description>So far, we have learn the basic and a not-so-common nested usage of JSR 303 Bean Validation, it’s time to learn how the declarative validation rule was implemented. In another word, we will learn to create a custom constraint this this post.
Constraint Annotation
Custom constraint is a special kind of annotation that is itself annotated with @javax.validation.Constraint annotation. For example:
@Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy=CustomeValidator.class) public @interface CustomConstraint { String message() default &amp;quot;Custom validation failed&amp;quot;; Class[] groups() default {}; Class&amp;lt;?</description></item><item><title>JSR 303 – Bean Validation – Nested Validation</title><link>/blog/jsr-303-bean-validation-nested-validation/</link><pubDate>Thu, 09 Aug 2012 09:19:42 +0100</pubDate><guid>/blog/jsr-303-bean-validation-nested-validation/</guid><description>Following up from my previous post about JSR 303 – Bean Validation, we will see how to apply it to any nested property and how to display validation error on screen using Spring MVC’s JSP tags
1. Bean Validation on Nested Property
Recall that to validate any property, we only need to put a Constraint annotation on top of its declaration. Example of common constraints are @NotEmpty, @Pattern, @Email. One thing in common of these constraints are that the applied property has to be of type String.</description></item><item><title>JSR 303 – Bean Validation – Basic</title><link>/blog/jsr-303-bean-validation-basic/</link><pubDate>Fri, 03 Aug 2012 09:19:42 +0100</pubDate><guid>/blog/jsr-303-bean-validation-basic/</guid><description>JSR 303 – Bean Validation is defines a metadata model and API for JavaBean validation. The metadata is primarily in Annotation forms, with the possibility of being overridden or extended by XML descriptors. Hibernate Validator is the reference implementation of JSR 303.
The current version, as of August 2nd, 2012, of JSR303 is 1.0, and of Hibernate Validator version is 4.0.1.
1. Example
A straightforward use of Bean Validation is to document and specify validation rules on JavaBean’s properties.</description></item><item><title>ILLEGAL SPORT BETTING DURING EURO CUP</title><link>/blog/illegal-sport-betting-during-euro-cup/</link><pubDate>Tue, 10 Jul 2012 09:19:42 +0100</pubDate><guid>/blog/illegal-sport-betting-during-euro-cup/</guid><description/></item><item><title>SPRING MVC – SESSIONATTRIBUTES ANNOTATION</title><link>/blog/spring-mvc-sessionattributes-annotation/</link><pubDate>Sat, 30 Jun 2012 09:19:42 +0100</pubDate><guid>/blog/spring-mvc-sessionattributes-annotation/</guid><description>Spring MVC’s SessionAttributes has 2 parameters: values (storing attributes’ names) and types (storing attributes’ types).
It’s pretty straightforward for values. You specify the name of your attribute and it is remembered.
It’s trickier for types. For example:
– @SessionAttributes (types= java.util.List.class) does not work!
– But @SessionAttributes (types= java.util.ArrayList.class) works (but not always)
The reason behind this peculiar behaviour is that Spring does exact matching of attribute’s type versus declared type, instead of assessing attribute object’s Is-A relationship.</description></item><item><title>HOW YOUR CONSUMPTION BENEFIT SOCIETY?</title><link>/blog/how-your-consumption-benefit-society/</link><pubDate>Wed, 27 Jun 2012 09:19:42 +0100</pubDate><guid>/blog/how-your-consumption-benefit-society/</guid><description>(Disclaimer: I’m no economist. I simply find this story/concept interesting and want to share it)
If you initially have $2000 cash and you buy yourself a new smartphone (or any other good). Let’s say it costs you $1000.
So, after your buying:
– You have $1000 left
– Seller have $1000 revenue
– You have a good (i.e. the phone) worth $1000.
Thus your initial $2000 is split into 3 pieces which in total worth $3000.</description></item></channel></rss>